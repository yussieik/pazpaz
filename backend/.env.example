# Application
DEBUG=true
APP_NAME=PazPaz
API_V1_PREFIX=/api/v1
ENVIRONMENT=local

# Database
# SECURITY: In production, database credentials are stored in AWS Secrets Manager
# Local development uses DATABASE_URL environment variable
# Production uses AWS Secrets Manager secret: pazpaz/database-credentials
#
# Local Development: Set DATABASE_URL with your local credentials
# Generate password with: openssl rand -base64 32 | tr -d '/+='
# Minimum 32 characters required for production, 20 for development
DATABASE_URL=postgresql+asyncpg://pazpaz:CHANGE_ME_GENERATE_RANDOM_32_CHARS@localhost:5432/pazpaz
#
# Production AWS Secrets Manager Configuration:
# Use AWS CLI or Console to create secret with this JSON format:
# {
#   "username": "pazpaz",
#   "password": "GENERATED_STRONG_PASSWORD",
#   "host": "prod-db.internal",
#   "port": 5432,
#   "database": "pazpaz",
#   "ssl_cert_path": "/etc/ssl/certs/rds-ca-2019-root.pem"
# }
#
# Create secret with AWS CLI:
# aws secretsmanager create-secret \
#   --name pazpaz/database-credentials \
#   --description "PazPaz production database credentials" \
#   --secret-string file://db-credentials.json
#
# Password Requirements:
#   - Minimum 32 characters (64 recommended)
#   - Include uppercase, lowercase, numbers, symbols
#   - No dictionary words or sequential characters
#   - Rotate every 90 days (HIPAA requirement)
#
# Generate strong password:
#   openssl rand -base64 48 | tr -d '/+=' | cut -c1-64
#
# AWS Secrets Manager Secret Name (override if needed):
DB_SECRETS_MANAGER_KEY_NAME=pazpaz/database-credentials

# Database SSL/TLS Configuration
# SECURITY: Production MUST use verify-ca or verify-full
# - verify-full: Verify certificate AND hostname (CA-signed certs, RECOMMENDED for production)
# - verify-ca: Verify certificate only (self-signed certs or hostname mismatch)
# - require: Encrypt but DON'T verify certificate (DEVELOPMENT ONLY, INSECURE)
#
# HIPAA Requirement: §164.312(e)(1) - Transmission Security
#
# SSL Modes Explained:
# ┌──────────────┬─────────────┬──────────────┬──────────────────────────────────┐
# │ Mode         │ Encryption  │ Verify Cert  │ Use Case                         │
# ├──────────────┼─────────────┼──────────────┼──────────────────────────────────┤
# │ verify-full  │ ✅ TLS 1.2+ │ ✅ Cert + CN │ Production (CA-signed certs)     │
# │ verify-ca    │ ✅ TLS 1.2+ │ ✅ Cert only │ Dev (self-signed) or AWS RDS     │
# │ require      │ ✅ TLS 1.2+ │ ❌ None      │ Dev only (INSECURE, MITM risk)   │
# │ prefer       │ ⚠️  Maybe   │ ❌ None      │ NEVER USE (downgrades to plain)  │
# │ disable      │ ❌ None     │ ❌ None      │ NEVER USE (HIPAA violation)      │
# └──────────────┴─────────────┴──────────────┴──────────────────────────────────┘
#
# Development: Use self-signed certificates (generated via scripts/generate_ssl_certs.sh)
# Production: Use CA-signed certificates (AWS RDS, Let's Encrypt, etc.)
#
DB_SSL_ENABLED=true
DB_SSL_MODE=verify-ca  # Development with self-signed certs
# DB_SSL_MODE=verify-full  # Production with CA-signed certs
DB_SSL_CA_CERT_PATH=/Users/yussieik/Desktop/projects/pazpaz/backend/certs/ca-cert.pem
DB_SSL_CLIENT_CERT_PATH=
DB_SSL_CLIENT_KEY_PATH=
#
# Production AWS RDS SSL Configuration:
# DB_SSL_MODE=verify-full
# DB_SSL_CA_CERT_PATH=/path/to/rds-ca-2019-root.pem
# Download RDS CA: https://truststore.pki.rds.amazonaws.com/global/global-bundle.pem
#
# To generate self-signed certificates for development:
#   ./backend/scripts/generate_ssl_certs.sh
#
# To download AWS RDS CA certificate:
#   curl -o /etc/ssl/certs/rds-ca-2019-root.pem \
#     https://truststore.pki.rds.amazonaws.com/global/global-bundle.pem

# Redis
# Generate strong password with: openssl rand -base64 32 | tr -d '/+='
# Minimum 32 characters required
REDIS_PASSWORD=CHANGE_ME_GENERATE_RANDOM_32_CHARS
REDIS_URL=redis://:CHANGE_ME_GENERATE_RANDOM_32_CHARS@localhost:6379/0

# Security
# Generate with: openssl rand -hex 32
# Minimum 64 characters required for production (32 bytes hex-encoded)
SECRET_KEY=CHANGE_ME_GENERATE_64_CHAR_HEX_STRING
ACCESS_TOKEN_EXPIRE_MINUTES=10080

# CSRF Protection
CSRF_TOKEN_EXPIRE_MINUTES=10080

# Content-Type Validation
# SECURITY: Content-Type validation middleware prevents parser confusion attacks
# - POST/PUT/PATCH/DELETE requests MUST have correct Content-Type header
# - JSON endpoints require "application/json"
# - File upload endpoints require "multipart/form-data"
# - Returns 415 Unsupported Media Type for incorrect Content-Type
# - No configuration needed (always enabled, uses DEBUG flag for behavior)
# - Production: Strict validation (fail-closed)
# - Development: Lenient (logs warning but continues) for easier testing
# Reference: OWASP API8:2023 Security Misconfiguration

# Content Security Policy (CSP) - Nonce-Based XSS Protection
# SECURITY: CSP prevents XSS attacks by controlling what resources can execute
# - Production/Staging: Strict nonce-based CSP (NO unsafe-inline, NO unsafe-eval)
# - Development/Local: Permissive CSP (allows unsafe-inline/eval for Vite HMR)
# - Nonce rotates per request (cryptographically secure, 256-bit random)
# - Frontend receives nonce via X-CSP-Nonce response header
#
# How it works:
# 1. Backend generates unique nonce per request (secrets.token_urlsafe(32))
# 2. Nonce stored in request.state.csp_nonce for middleware/endpoint access
# 3. CSP header includes nonce: script-src 'self' 'nonce-ABC123...'
# 4. X-CSP-Nonce header returns nonce to frontend
# 5. Frontend adds nonce to inline scripts: <script nonce="ABC123...">
# 6. Browser only executes scripts with matching nonce attribute
#
# Production CSP directives:
# - default-src 'self'                  # Default: only same origin
# - script-src 'self' 'nonce-{NONCE}'   # Scripts: only with matching nonce
# - style-src 'self' 'nonce-{NONCE}'    # Styles: only with matching nonce
# - img-src 'self' data: https:         # Images: self, data URIs, HTTPS
# - font-src 'self' data:               # Fonts: self, data URIs
# - connect-src 'self'                  # API calls: only same origin
# - frame-ancestors 'none'              # Disallow framing (clickjacking prevention)
# - base-uri 'self'                     # Restrict <base> tag
# - form-action 'self'                  # Forms only submit to same origin
# - upgrade-insecure-requests           # Upgrade HTTP to HTTPS (production only)
#
# Development CSP directives:
# - Adds 'unsafe-inline' and 'unsafe-eval' for Vite HMR
# - Allows http://localhost:* and ws://localhost:* for Vite dev server
# - No upgrade-insecure-requests (development uses HTTP)
#
# Environment detection:
# - Production CSP: DEBUG=false AND ENVIRONMENT=production/staging
# - Development CSP: DEBUG=true OR ENVIRONMENT=local
#
# No configuration needed (CSP automatically adapts to environment)
#
# Security benefits:
# - Blocks XSS attacks from injected inline scripts (attacker has no nonce)
# - Prevents eval()-based code execution attacks
# - Defense-in-depth: Even if attacker bypasses input validation, CSP blocks execution
# - OWASP Top 10: A03:2021 Injection (XSS prevention)
#
# Frontend integration guide:
# - Backend returns nonce in X-CSP-Nonce header
# - Frontend extracts nonce: const nonce = response.headers.get('X-CSP-Nonce')
# - Add to inline scripts: <script nonce={nonce}>...</script>
# - Add to inline styles: <style nonce={nonce}>...</style>
# - Vite production builds automatically use nonce for code splitting chunks
#
# Reference: OWASP A03:2021 Injection, CSP Level 3 Specification

# Encryption (local/dev only - use AWS Secrets Manager in production)
# SECURITY WARNING: Never commit real encryption keys to git!
# This key encrypts PHI (client names, contacts, session notes, attachments)
#
# Generate with: python3 -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())"
# Must be 44-character base64-encoded Fernet key (32 bytes + base64 encoding)
#
# CRITICAL PRODUCTION REQUIREMENT:
# - Production/Staging MUST use AWS Secrets Manager (see AWS_SECRETS_MANAGER_SETUP.md)
# - Local development can use environment variable (acceptable risk)
# - NEVER commit production keys to version control
# - Loss of this key = permanent data loss (no recovery possible)
ENCRYPTION_MASTER_KEY=CHANGE_ME_GENERATE_BASE64_32_BYTES

# AWS Secrets Manager Configuration
# PRODUCTION REQUIREMENT: All secrets stored in AWS Secrets Manager
# See docs/deployment/AWS_SECRETS_MANAGER_SETUP.md for setup instructions
#
# How it works:
# - Production/Staging: Application fetches secrets from AWS Secrets Manager at runtime
# - Local Development: Application uses environment variables from .env file
# - No code changes needed (automatic detection based on ENVIRONMENT)
#
# Secrets stored in AWS Secrets Manager:
# 1. pazpaz/encryption-key-v2 - Encryption master key (AES-256-GCM)
# 2. pazpaz/jwt-secret - JWT signing key (authentication tokens)
# 3. pazpaz/database-credentials - PostgreSQL connection credentials
# 4. pazpaz/redis-url - Redis connection string
#
# HIPAA Compliance Benefits:
# - Centralized secret management (single audit point)
# - Automatic rotation (90-day requirement)
# - Comprehensive audit trail (CloudTrail logs all access)
# - No secrets in version control (eliminates git exposure)
# - Encryption at rest (AWS KMS AES-256)
# - Encryption in transit (TLS 1.2+ for API calls)
#
# IAM Permissions Required:
# - Application task role must have secretsmanager:GetSecretValue permission
# - See docs/deployment/AWS_IAM_ROLES.md for IAM policy configuration
#
AWS_REGION=us-east-1
SECRETS_MANAGER_KEY_NAME=pazpaz/encryption-key-v2  # Current encryption key version
DB_SECRETS_MANAGER_KEY_NAME=pazpaz/database-credentials  # Database credentials secret

# Migration from v1 to v2:
# If you have existing data encrypted with pazpaz/encryption-key-v1:
# - Keep v1 secret active for decryption of historical data
# - Set SECRETS_MANAGER_KEY_NAME=pazpaz/encryption-key-v2 for NEW encryptions
# - See docs/security/encryption/KEY_ROTATION_PROCEDURE.md for full migration steps
# - DO NOT delete v1 until all historical data re-encrypted with v2

# S3/MinIO Storage
# Development: Use MinIO (localhost:9000)
# Production: Use AWS S3 with https:// endpoint
#
# SECURITY WARNING: Never use default credentials in production!
# Default credentials (minioadmin/minioadmin123) are ONLY acceptable for
# local development on localhost (127.0.0.1). Change immediately if:
# - MinIO is exposed to network (0.0.0.0 or public IP)
# - Deploying to staging or production environments
# - Running on shared development servers
#
# Generate strong credentials with:
#   openssl rand -base64 16 | tr -d '/+=' | cut -c1-16  # Username (16 chars)
#   openssl rand -base64 32 | tr -d '/+=' | cut -c1-32  # Password (32 chars)
#
# Password Requirements:
#   - Minimum 20 characters (32 recommended)
#   - Include uppercase, lowercase, numbers, symbols
#   - No dictionary words or sequential characters
#   - Rotate every 90 days (production), 180 days (development)
#
# See docs/storage/S3_CREDENTIAL_MANAGEMENT.md for full guidance
#
# Generate credentials:
#   Access Key (16+ chars): openssl rand -base64 16 | tr -d '/+=' | cut -c1-16
#   Secret Key (32+ chars): openssl rand -base64 32 | tr -d '/+='
S3_ENDPOINT_URL=http://localhost:9000
S3_ACCESS_KEY=CHANGE_ME_16_CHARS  # Min 12 chars (16 recommended)
S3_SECRET_KEY=CHANGE_ME_GENERATE_RANDOM_32_CHARS  # Min 20 chars (32 recommended)
S3_BUCKET_NAME=pazpaz-attachments
S3_REGION=us-east-1
#
# Production AWS S3 Configuration:
# For production, use AWS IAM roles (preferred) or AWS Secrets Manager:
# - IAM Roles: Leave S3_ACCESS_KEY and S3_SECRET_KEY empty (boto3 uses role)
# - Secrets Manager: Fetch credentials at runtime (see S3_CREDENTIAL_MANAGEMENT.md)
# - S3_ENDPOINT_URL: Leave empty for AWS S3 (uses default https endpoint)
#
# Production Example (IAM Role):
#   S3_ENDPOINT_URL=
#   S3_ACCESS_KEY=
#   S3_SECRET_KEY=
#   S3_BUCKET_NAME=pazpaz-attachments-prod
#   S3_REGION=us-west-2

# MinIO Server-Side Encryption (Development)
# HIPAA Requirement: §164.312(a)(2)(iv) - Encryption at rest for PHI
#
# Generate encryption key with:
#   python3 -c "import secrets,base64; print(base64.b64encode(secrets.token_bytes(32)).decode())"
#
# CRITICAL: This key encrypts all file attachments (SOAP notes, photos, PDFs).
# - Development: Use environment variable below
# - Production: Use external KMS (AWS KMS, HashiCorp Vault)
# - Rotate every 90 days (HIPAA requirement)
#
# Key Requirements:
#   - Must be 32 bytes (256 bits) minimum
#   - Base64-encoded for MinIO KMS format
#   - Never commit actual key to version control
#   - Store production keys in AWS Secrets Manager
#
MINIO_ENCRYPTION_KEY=CHANGE_ME_GENERATE_BASE64_32_BYTES

# Workspace Storage Quotas
# HIPAA Requirement: §164.308(a)(7)(ii)(B) - Resource management to prevent abuse
#
# DEFAULT_WORKSPACE_STORAGE_QUOTA_GB: Default storage quota for new workspaces (in gigabytes)
# - Default: 10 GB (reasonable for typical therapy practice with SOAP notes + photos)
# - Calculation: ~1000 sessions × 5 photos/session × 2 MB/photo = ~10 GB
# - Adjust per workspace via API: PATCH /api/v1/workspaces/{id}/storage/quota
#
# Storage quota prevents:
# - Storage abuse (malicious or accidental over-uploading)
# - Runaway storage costs (AWS S3/MinIO)
# - Workspace resource exhaustion
#
# Quota enforcement:
# - Validated BEFORE S3 upload (fail fast, no wasted bandwidth)
# - Atomically updated AFTER successful upload/delete (prevents race conditions)
# - Logged for monitoring (quota rejections, usage updates)
# - 507 Insufficient Storage error when quota exceeded
#
# Monitor via API:
# - GET /api/v1/workspaces/{id}/storage - View current usage, quota, percentage
#
DEFAULT_WORKSPACE_STORAGE_QUOTA_GB=10

# Frontend
FRONTEND_URL=http://localhost:5173

# Email
SMTP_HOST=localhost
SMTP_PORT=1025
SMTP_USER=
SMTP_PASSWORD=
EMAILS_FROM_EMAIL=noreply@pazpaz.local

# External Services (Production)
# RESEND_API_KEY=re_xxxxxxxxxxxxxxxxxxxx  # Email service API key from https://resend.com
# SENTRY_DSN=https://xxxxx@sentry.io/xxxxx  # Error tracking from https://sentry.io

# CI/CD Deployment Configuration
# These are used by GitHub Actions for automated deployment
# Store these in GitHub Secrets, not in .env files
#
# SSH_HOST=your.server.ip.address  # Deployment server IP or hostname
# SSH_USER=deploy  # User with deployment permissions
# SSH_PRIVATE_KEY=<private key content>  # Ed25519 or RSA private key
# DOCKER_REGISTRY=ghcr.io  # Container registry (GitHub Container Registry)
# DOCKER_REGISTRY_USER=<github-username>
# DOCKER_REGISTRY_TOKEN=<github-personal-access-token>