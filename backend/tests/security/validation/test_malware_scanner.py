"""Tests for malware scanning with ClamAV integration.

This test suite validates the malware scanner functionality, including:
- EICAR test virus detection
- Clean file acceptance
- Scanner unavailable scenarios (fail-closed in production, fail-open in dev)
- Connection error handling
- Environment-based behavior (production vs development)
"""

from __future__ import annotations

from unittest.mock import MagicMock, patch

import clamd
import pytest

from pazpaz.utils.malware_scanner import (
    MalwareDetectedError,
    ScannerUnavailableError,
    scan_file_for_malware,
)

# EICAR test virus string (harmless test string for antivirus testing)
# This is a standard test file used by antivirus vendors to test detection
# It is NOT malware and is safe to use in tests
EICAR_TEST_VIRUS = (
    b"X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"
)


class TestMalwareScanning:
    """Test malware scanning functionality."""

    def test_clean_file_passes_scan(self, mock_clamav_clean):
        """Test that clean files pass malware scan."""
        clean_file_content = b"This is a clean PDF file content"

        # Should not raise any exception
        scan_file_for_malware(clean_file_content, "clean_document.pdf")

    def test_eicar_virus_detected(self, mock_clamav_eicar):
        """Test that EICAR test virus is detected and rejected."""
        with pytest.raises(MalwareDetectedError, match="Eicar-Test-Signature"):
            scan_file_for_malware(EICAR_TEST_VIRUS, "eicar.txt")

    def test_malware_detected_with_virus_name(self, mock_clamav_malware):
        """Test malware detection with custom virus name."""
        with pytest.raises(MalwareDetectedError, match="Win.Test.Trojan"):
            scan_file_for_malware(b"fake_malware_content", "malware.exe")

    def test_scanner_unavailable_production_fails_closed(
        self, mock_clamav_connection_error, mock_environment_production
    ):
        """Test that scanner unavailable in production fails closed (rejects upload)."""
        with pytest.raises(
            ScannerUnavailableError, match="Malware scanner unavailable"
        ):
            scan_file_for_malware(b"file_content", "document.pdf")

    def test_scanner_unavailable_staging_fails_closed(
        self, mock_clamav_connection_error, mock_environment_staging
    ):
        """Test that scanner unavailable in staging fails closed (rejects upload)."""
        with pytest.raises(
            ScannerUnavailableError, match="Malware scanner unavailable"
        ):
            scan_file_for_malware(b"file_content", "document.pdf")

    def test_scanner_unavailable_development_fails_open(
        self, mock_clamav_connection_error, mock_environment_local
    ):
        """Test scanner unavailable in dev fails open (allows upload)."""
        # Should not raise exception in development
        scan_file_for_malware(b"file_content", "document.pdf")

    def test_scanner_ping_failure_production(
        self, mock_clamav_ping_failure, mock_environment_production
    ):
        """Test that ping failure in production fails closed."""
        with pytest.raises(
            ScannerUnavailableError, match="Malware scanner unavailable"
        ):
            scan_file_for_malware(b"file_content", "document.pdf")

    def test_scanner_ping_failure_development(
        self, mock_clamav_ping_failure, mock_environment_local
    ):
        """Test that ping failure in development fails open."""
        # Should not raise exception in development
        scan_file_for_malware(b"file_content", "document.pdf")

    def test_unexpected_scan_error_production(
        self, mock_clamav_unexpected_error, mock_environment_production
    ):
        """Test that unexpected scan errors in production fail closed."""
        with pytest.raises(ScannerUnavailableError, match="Malware scan failed"):
            scan_file_for_malware(b"file_content", "document.pdf")

    def test_unexpected_scan_error_development(
        self, mock_clamav_unexpected_error, mock_environment_local
    ):
        """Test that unexpected scan errors in development fail open."""
        # Should not raise exception in development
        scan_file_for_malware(b"file_content", "document.pdf")

    def test_invalid_clamav_response_production(
        self, mock_clamav_invalid_response, mock_environment_production
    ):
        """Test handling of invalid ClamAV response format in production."""
        # Should raise ScannerUnavailableError in production
        with pytest.raises(ScannerUnavailableError, match="Malware scan failed"):
            scan_file_for_malware(b"file_content", "document.pdf")

    def test_invalid_clamav_response_development(
        self, mock_clamav_invalid_response, mock_environment_local
    ):
        """Test handling of invalid ClamAV response format in development."""
        # Should not raise exception in development (fail open)
        scan_file_for_malware(b"file_content", "document.pdf")


class TestPerformanceImpact:
    """Test performance impact of malware scanning."""

    def test_scan_performance_acceptable(self, mock_clamav_clean):
        """Test that malware scanning completes within acceptable time."""
        import time

        file_content = b"x" * (1024 * 1024)  # 1 MB file
        start_time = time.time()

        scan_file_for_malware(file_content, "large_file.pdf")

        elapsed_time = time.time() - start_time

        # Scan should complete in <1 second (actual ClamAV is ~100-500ms)
        # This is a mock test, so it should be near-instant
        assert elapsed_time < 1.0, f"Scan took {elapsed_time}s (too slow)"


class TestEdgeCases:
    """Test edge cases and error handling."""

    def test_empty_file_scan(self, mock_clamav_clean):
        """Test scanning of empty file."""
        scan_file_for_malware(b"", "empty.txt")

    def test_large_file_scan(self, mock_clamav_clean):
        """Test scanning of large file (10 MB)."""
        large_file = b"x" * (10 * 1024 * 1024)  # 10 MB
        scan_file_for_malware(large_file, "large.pdf")

    def test_unicode_filename(self, mock_clamav_clean):
        """Test scanning file with Unicode filename."""
        scan_file_for_malware(b"content", "文档.pdf")

    def test_special_characters_filename(self, mock_clamav_clean):
        """Test scanning file with special characters in filename."""
        scan_file_for_malware(b"content", "file's_name (1) [test].pdf")


# Fixtures


@pytest.fixture
def mock_clamav_clean():
    """Mock ClamAV to return clean scan result."""
    with patch("clamd.ClamdNetworkSocket") as mock_clamd:
        mock_instance = MagicMock()
        mock_instance.ping.return_value = True
        mock_instance.instream.return_value = {"stream": ("OK", None)}
        mock_clamd.return_value = mock_instance
        yield mock_instance


@pytest.fixture
def mock_clamav_eicar():
    """Mock ClamAV to detect EICAR test virus."""
    with patch("clamd.ClamdNetworkSocket") as mock_clamd:
        mock_instance = MagicMock()
        mock_instance.ping.return_value = True
        mock_instance.instream.return_value = {
            "stream": ("FOUND", "Eicar-Test-Signature")
        }
        mock_clamd.return_value = mock_instance
        yield mock_instance


@pytest.fixture
def mock_clamav_malware():
    """Mock ClamAV to detect generic malware."""
    with patch("clamd.ClamdNetworkSocket") as mock_clamd:
        mock_instance = MagicMock()
        mock_instance.ping.return_value = True
        mock_instance.instream.return_value = {"stream": ("FOUND", "Win.Test.Trojan")}
        mock_clamd.return_value = mock_instance
        yield mock_instance


@pytest.fixture
def mock_clamav_connection_error():
    """Mock ClamAV connection error (service unavailable)."""
    with patch("clamd.ClamdNetworkSocket") as mock_clamd:
        mock_clamd.side_effect = clamd.ConnectionError("Connection refused")
        yield mock_clamd


@pytest.fixture
def mock_clamav_ping_failure():
    """Mock ClamAV ping failure."""
    with patch("clamd.ClamdNetworkSocket") as mock_clamd:
        mock_instance = MagicMock()
        mock_instance.ping.return_value = False
        mock_clamd.return_value = mock_instance
        yield mock_instance


@pytest.fixture
def mock_clamav_unexpected_error():
    """Mock unexpected error during scan."""
    with patch("clamd.ClamdNetworkSocket") as mock_clamd:
        mock_instance = MagicMock()
        mock_instance.ping.return_value = True
        mock_instance.instream.side_effect = RuntimeError("Unexpected error")
        mock_clamd.return_value = mock_instance
        yield mock_instance


@pytest.fixture
def mock_clamav_invalid_response():
    """Mock invalid ClamAV response format."""
    with patch("clamd.ClamdNetworkSocket") as mock_clamd:
        mock_instance = MagicMock()
        mock_instance.ping.return_value = True
        mock_instance.instream.return_value = {}  # Missing 'stream' key
        mock_clamd.return_value = mock_instance
        yield mock_instance


@pytest.fixture
def mock_environment_production(monkeypatch):
    """Set environment to production."""
    monkeypatch.setenv("ENVIRONMENT", "production")
    # Override SSL and S3 settings to pass production validation
    monkeypatch.setenv("DB_SSL_MODE", "verify-full")
    monkeypatch.setenv("S3_ENDPOINT_URL", "https://s3.amazonaws.com")
    # Reload settings to pick up new environment
    from pazpaz.core.config import Settings

    settings = Settings()
    with patch("pazpaz.utils.malware_scanner.settings", settings):
        yield settings


@pytest.fixture
def mock_environment_staging(monkeypatch):
    """Set environment to staging."""
    monkeypatch.setenv("ENVIRONMENT", "staging")
    # Override SSL and S3 settings to pass staging validation
    monkeypatch.setenv("DB_SSL_MODE", "verify-full")
    monkeypatch.setenv("S3_ENDPOINT_URL", "https://s3.amazonaws.com")
    from pazpaz.core.config import Settings

    settings = Settings()
    with patch("pazpaz.utils.malware_scanner.settings", settings):
        yield settings


@pytest.fixture
def mock_environment_local(monkeypatch):
    """Set environment to local (development)."""
    monkeypatch.setenv("ENVIRONMENT", "local")
    from pazpaz.core.config import Settings

    settings = Settings()
    with patch("pazpaz.utils.malware_scanner.settings", settings):
        yield settings
