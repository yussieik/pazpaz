# =============================================================================
# Production Deployment Pipeline for PazPaz
# =============================================================================
# Continuous Deployment workflow implementing zero-downtime deployment with
# comprehensive health checks and HIPAA compliance.
#
# Features:
#   - Direct Docker Compose deployment (simple and reliable)
#   - Database migration support with automatic backups
#   - SSH-based deployment to production servers
#   - Comprehensive health checks and smoke tests
#   - Configuration rollback on failure
#   - Slack/Discord notification support
#   - Deployment tracking and metrics
#
# Required Secrets (see docs/deployment/github-cd-secrets.md):
#   - SSH_PRIVATE_KEY: ED25519 SSH key for server access
#   - SSH_HOST: Production server hostname/IP
#   - SSH_USER: Deployment user (non-root)
#   - SSH_PORT: SSH port (default: 22)
#   - GHCR_TOKEN: GitHub Container Registry PAT
#   - DOMAIN: Production domain (e.g., pazpaz.health)
#   - SLACK_WEBHOOK_URL: (Optional) Slack notifications
#   - SENTRY_AUTH_TOKEN: (Optional) Sentry release tracking
# =============================================================================

name: Deploy Production

on:
  # Automatic deployment after CI passes on main branch
  workflow_run:
    workflows: ["Backend CI"]
    types:
      - completed
    branches:
      - main

  # Manual deployment with options
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        default: 'latest'
        type: string
      skip_migrations:
        description: 'Skip database migrations'
        required: false
        default: false
        type: boolean
      skip_health_checks:
        description: 'Skip post-deployment health checks (dangerous!)'
        required: false
        default: false
        type: boolean
      dry_run:
        description: 'Perform dry run without actual deployment'
        required: false
        default: false
        type: boolean
      force_deployment:
        description: 'Force deployment even with warnings'
        required: false
        default: false
        type: boolean

  # Automatic deployment on version tags
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'  # Semantic versioning tags (v1.2.3)

# Permissions required for deployments and environment protection
permissions:
  contents: read
  deployments: write
  actions: read

env:
  DEPLOYMENT_DIR: /opt/pazpaz
  SCRIPTS_DIR: /opt/pazpaz/scripts
  BACKUP_DIR: /opt/pazpaz/backups
  LOG_DIR: /opt/pazpaz/logs
  # Timeouts
  DEPLOYMENT_TIMEOUT: 600  # 10 minutes max
  HEALTH_CHECK_TIMEOUT: 120  # 2 minutes for health checks
  SMOKE_TEST_TIMEOUT: 60  # 1 minute for smoke tests

# Concurrency to prevent multiple simultaneous deployments
concurrency:
  group: deployment-${{ inputs.environment || 'production' }}
  cancel-in-progress: false  # Never cancel deployments in progress

jobs:
  # =============================================================================
  # Pre-deployment Validation
  # =============================================================================
  validate:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      image_tag: ${{ steps.determine_tag.outputs.tag }}
      environment: ${{ steps.determine_env.outputs.environment }}
      deployment_id: ${{ steps.generate_id.outputs.id }}

    steps:
      - name: Check CI workflow conclusion
        if: github.event_name == 'workflow_run'
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
            echo "‚ùå Backend CI did not succeed. Conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Deployment will not proceed."
            exit 1
          fi
          echo "‚úÖ Backend CI passed successfully"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for tag detection

      - name: Determine image tag
        id: determine_tag
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG="${{ inputs.image_tag }}"
          elif [ "${{ github.event_name }}" = "workflow_run" ]; then
            # Use latest tag for automatic deployments from main
            TAG="latest"
          else
            # Extract tag from ref (e.g., refs/tags/v1.2.3 -> v1.2.3)
            TAG="${GITHUB_REF#refs/tags/}"
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "üì¶ Image tag to deploy: $TAG"

      - name: Determine environment
        id: determine_env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENV="${{ inputs.environment }}"
          else
            # Automatic deployments from tags go to production
            ENV="production"
          fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "üéØ Target environment: $ENV"

      - name: Generate deployment ID
        id: generate_id
        run: |
          ID="deploy-$(date +%Y%m%d-%H%M%S)-${GITHUB_RUN_NUMBER}"
          echo "id=$ID" >> $GITHUB_OUTPUT
          echo "üîë Deployment ID: $ID"

      - name: Validate secrets are configured
        run: |
          echo "Validating required secrets..."

          # Check required secrets
          MISSING_SECRETS=""

          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            MISSING_SECRETS="${MISSING_SECRETS} SSH_PRIVATE_KEY"
          fi
          if [ -z "${{ secrets.SSH_HOST }}" ]; then
            MISSING_SECRETS="${MISSING_SECRETS} SSH_HOST"
          fi
          if [ -z "${{ secrets.SSH_USER }}" ]; then
            MISSING_SECRETS="${MISSING_SECRETS} SSH_USER"
          fi
          if [ -z "${{ secrets.DOMAIN }}" ]; then
            MISSING_SECRETS="${MISSING_SECRETS} DOMAIN"
          fi

          if [ -n "$MISSING_SECRETS" ]; then
            echo "‚ùå Missing required secrets:$MISSING_SECRETS"
            echo "Please configure these secrets in GitHub Settings > Secrets"
            echo "See docs/deployment/github-cd-secrets.md for instructions"
            exit 1
          fi

          echo "‚úÖ All required secrets are configured"

      - name: Check CI status
        if: github.event_name == 'push'
        run: |
          echo "Checking CI workflow status..."

          # Get the commit SHA for the tag
          COMMIT_SHA=$(git rev-list -n 1 ${{ steps.determine_tag.outputs.tag }})

          # Check if backend CI passed for this commit
          gh run list \
            --workflow="Backend CI" \
            --commit="$COMMIT_SHA" \
            --limit=1 \
            --json status,conclusion | \
            jq -r '.[0] | "\(.status) - \(.conclusion)"'

          # Note: In production, you'd want to ensure CI passed
          echo "‚ö†Ô∏è Warning: Skipping CI status check for MVP"
        env:
          GH_TOKEN: ${{ github.token }}
        continue-on-error: true

      - name: Verify Docker images exist
        run: |
          echo "Verifying Docker images are available..."
          IMAGE_TAG="${{ steps.determine_tag.outputs.tag }}"

          # Check backend image (matches backend-ci.yml naming: pazpaz-backend)
          echo "Checking backend image: ghcr.io/yussieik/pazpaz-backend:${IMAGE_TAG}"
          docker manifest inspect "ghcr.io/yussieik/pazpaz-backend:${IMAGE_TAG}" > /dev/null 2>&1 || {
            echo "‚ùå Backend image not found. Ensure CI/CD builds have completed."
            exit 1
          }

          # Check frontend image (matches frontend-ci.yml naming: pazpaz-frontend)
          echo "Checking frontend image: ghcr.io/yussieik/pazpaz-frontend:${IMAGE_TAG}"
          docker manifest inspect "ghcr.io/yussieik/pazpaz-frontend:${IMAGE_TAG}" > /dev/null 2>&1 || {
            echo "‚ùå Frontend image not found. Ensure CI/CD builds have completed."
            exit 1
          }

          echo "‚úÖ All required Docker images are available"

  # =============================================================================
  # Main Deployment Job
  # =============================================================================
  deploy:
    name: Deploy to ${{ needs.validate.outputs.environment }}
    runs-on: ubuntu-latest
    needs: validate
    timeout-minutes: 30
    environment:
      name: ${{ needs.validate.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup deployment info
        run: |
          echo "## üöÄ Deployment Information" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | ${{ needs.validate.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Image Tag** | ${{ needs.validate.outputs.image_tag }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Deployment ID** | ${{ needs.validate.outputs.deployment_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Triggered By** | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Trigger Event** | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Domain** | https://${{ secrets.DOMAIN }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Dry Run** | ${{ inputs.dry_run || false }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Skip Migrations** | ${{ inputs.skip_migrations || false }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh

          # Add SSH private key
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Configure SSH client
          cat >> ~/.ssh/config <<EOF
          Host production
            HostName ${{ secrets.SSH_HOST }}
            User ${{ secrets.SSH_USER }}
            Port ${{ secrets.SSH_PORT || 22 }}
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
            ServerAliveInterval 60
            ServerAliveCountMax 3
            ControlMaster auto
            ControlPath ~/.ssh/cm-%r@%h:%p
            ControlPersist 10m
          EOF

          # Test SSH connection
          echo "Testing SSH connection..."
          ssh production "echo '‚úÖ SSH connection successful'"

      - name: Verify server environment
        run: |
          echo "Verifying server environment..."

          ssh production << 'ENDSSH'
            set -e

            # Check Docker is installed and running
            if ! command -v docker &> /dev/null; then
              echo "‚ùå Docker is not installed"
              exit 1
            fi

            if ! docker info > /dev/null 2>&1; then
              echo "‚ùå Docker daemon is not running"
              exit 1
            fi
            echo "‚úÖ Docker is running"

            # Check Docker Compose (support both standalone and plugin versions)
            if command -v docker-compose &> /dev/null; then
              echo "‚úÖ Docker Compose (standalone) is available"
            elif docker compose version &> /dev/null; then
              echo "‚úÖ Docker Compose (plugin) is available"
            else
              echo "‚ùå Docker Compose is not installed"
              exit 1
            fi

            # Check deployment directory
            if [ ! -d "${{ env.DEPLOYMENT_DIR }}" ]; then
              echo "Creating deployment directory: ${{ env.DEPLOYMENT_DIR }}"
              sudo mkdir -p "${{ env.DEPLOYMENT_DIR }}"
              sudo chown $USER:$USER "${{ env.DEPLOYMENT_DIR }}"
            fi

            # Check disk space (require at least 20GB free)
            AVAILABLE_SPACE=$(df -BG "${{ env.DEPLOYMENT_DIR }}" | awk 'NR==2 {gsub("G",""); print $4}')
            if [ "$AVAILABLE_SPACE" -lt 20 ]; then
              echo "‚ö†Ô∏è Low disk space: ${AVAILABLE_SPACE}GB available"
            else
              echo "‚úÖ Disk space: ${AVAILABLE_SPACE}GB available"
            fi

            # Check if we can write to deployment directory
            touch "${{ env.DEPLOYMENT_DIR }}/.write_test" && rm "${{ env.DEPLOYMENT_DIR }}/.write_test"
            echo "‚úÖ Deployment directory is writable"
          ENDSSH

      - name: Deploy files to server
        run: |
          echo "Deploying files to server..."

          # Create tar archive of deployment files
          tar czf deployment.tar.gz \
            docker-compose.prod.yml \
            scripts/*.sh \
            nginx/ \
            frontend/nginx.prod.conf \
            .env.production.example

          # Copy archive to server
          scp deployment.tar.gz production:${{ env.DEPLOYMENT_DIR }}/

          # Extract on server
          ssh production << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOYMENT_DIR }}

            # Backup existing configuration
            if [ -f docker-compose.prod.yml ]; then
              cp docker-compose.prod.yml docker-compose.prod.yml.backup-$(date +%Y%m%d-%H%M%S)
            fi

            # Extract new files
            tar xzf deployment.tar.gz
            rm deployment.tar.gz

            # Ensure scripts are executable
            chmod +x scripts/*.sh

            # Verify files
            ls -la scripts/
            echo "‚úÖ Deployment files extracted successfully"
          ENDSSH

      - name: Login to GitHub Container Registry
        run: |
          ssh production << 'ENDSSH'
            echo "${{ secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}" | \
              docker login ghcr.io -u ${{ github.actor }} --password-stdin
            echo "‚úÖ Logged in to GitHub Container Registry"
          ENDSSH

      - name: Pull and restart API container with new image
        run: |
          echo "Pulling new Docker images and restarting API container..."

          ssh production << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOYMENT_DIR }}

            # Set image tag
            export IMAGE_TAG="${{ needs.validate.outputs.image_tag }}"

            # Update docker-compose.prod.yml to use specified image tag
            sed -i "s|image: ghcr.io/yussieik/pazpaz-backend:.*|image: ghcr.io/yussieik/pazpaz-backend:${IMAGE_TAG}|g" docker-compose.prod.yml
            sed -i "s|image: ghcr.io/yussieik/pazpaz-frontend:.*|image: ghcr.io/yussieik/pazpaz-frontend:${IMAGE_TAG}|g" docker-compose.prod.yml

            echo "Pulling backend and frontend images..."
            docker compose --env-file .env.production -f docker-compose.prod.yml pull api frontend

            echo "Restarting API container with new image (migrations will run inside new container)..."
            docker compose --env-file .env.production -f docker-compose.prod.yml up -d --no-deps api

            echo "Waiting for API container to be healthy..."
            TIMEOUT=60
            ELAPSED=0
            while [ $ELAPSED -lt $TIMEOUT ]; do
              # Check health without jq - parse docker ps output directly
              HEALTH=$(docker inspect ***-api --format='{{.State.Health.Status}}' 2>/dev/null || echo "")
              if [ "$HEALTH" = "healthy" ]; then
                echo "‚úÖ API container is healthy"
                break
              fi
              sleep 2
              ELAPSED=$((ELAPSED + 2))
            done

            if [ $ELAPSED -ge $TIMEOUT ]; then
              echo "‚ùå API container failed to become healthy"
              docker logs ***-api --tail 50
              exit 1
            fi

            echo "‚úÖ Docker images pulled and API container restarted successfully"
          ENDSSH

      - name: Run database migrations
        if: inputs.skip_migrations != true && inputs.dry_run != true
        run: |
          echo "Running database migrations..."

          ssh production << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOYMENT_DIR }}

            # Backup database before migration
            echo "Creating database backup..."
            docker exec pazpaz-db pg_dump -U pazpaz -d pazpaz > "backups/pre-migration-$(date +%Y%m%d-%H%M%S).sql"
            echo "‚úÖ Database backup created"

            # Run migrations via migrate.sh script
            if [ -f scripts/migrate.sh ]; then
              ./scripts/migrate.sh
            else
              # Fallback to direct alembic migration
              docker compose --env-file .env.production -f docker-compose.prod.yml exec -T api \
                alembic upgrade head
            fi

            echo "‚úÖ Database migrations completed"
          ENDSSH

      - name: Deploy application
        id: deployment
        run: |
          echo "Starting deployment..."
          DEPLOYMENT_START=$(date +%s)

          ssh production << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOYMENT_DIR }}

            # Note: Docker images already pulled in previous step
            echo "Deploying with Docker Compose..."
            if ${{ inputs.dry_run == true }}; then
              docker compose --env-file .env.production -f docker-compose.prod.yml config
              echo "‚úÖ Dry run completed - configuration is valid"
            else
              # Start/restart services with new images
              docker compose --env-file .env.production -f docker-compose.prod.yml up -d --no-build

              echo "Waiting for services to become healthy..."
              TIMEOUT=120
              ELAPSED=0

              while [ $ELAPSED -lt $TIMEOUT ]; do
                # Check if all required containers are healthy
                UNHEALTHY=$(docker compose --env-file .env.production -f docker-compose.prod.yml ps --format json | \
                  jq -r 'select(.Service == "api" or .Service == "frontend" or .Service == "nginx") | select(.Health != "healthy") | .Service' | wc -l)

                if [ "$UNHEALTHY" -eq 0 ]; then
                  echo "‚úÖ All services are healthy"
                  break
                fi

                echo "Waiting for services to become healthy... ($ELAPSED/$TIMEOUT seconds)"
                sleep 5
                ELAPSED=$((ELAPSED + 5))
              done

              if [ $ELAPSED -ge $TIMEOUT ]; then
                echo "‚ùå Health check timeout - services did not become healthy in time"
                echo "Container status:"
                docker compose --env-file .env.production -f docker-compose.prod.yml ps
                echo "Recent logs:"
                docker compose --env-file .env.production -f docker-compose.prod.yml logs --tail=50
                exit 1
              fi

              echo "‚úÖ Deployment completed successfully"
            fi
          ENDSSH

          DEPLOYMENT_END=$(date +%s)
          DEPLOYMENT_DURATION=$((DEPLOYMENT_END - DEPLOYMENT_START))
          echo "deployment_duration=$DEPLOYMENT_DURATION" >> $GITHUB_OUTPUT
          echo "‚è±Ô∏è Deployment completed in ${DEPLOYMENT_DURATION} seconds"

      - name: Run smoke tests
        id: smoke_tests
        if: inputs.dry_run != true
        run: |
          echo "Running smoke tests..."

          # Wait for services to stabilize
          sleep 30

          # API health check
          echo "Testing API health endpoint..."
          for i in {1..5}; do
            if curl -f -s "https://${{ secrets.DOMAIN }}/api/v1/health" | jq -e '.status == "healthy"' > /dev/null; then
              echo "‚úÖ API health check passed"
              break
            fi
            echo "Retry $i/5..."
            sleep 10
          done

          # Frontend check
          echo "Testing frontend..."
          if curl -f -s "https://${{ secrets.DOMAIN }}" | grep -q "PazPaz"; then
            echo "‚úÖ Frontend is accessible"
          else
            echo "‚ùå Frontend check failed"
            exit 1
          fi

          # Check SSL certificate
          echo "Checking SSL certificate..."
          echo | openssl s_client -connect "${{ secrets.DOMAIN }}:443" -servername "${{ secrets.DOMAIN }}" 2>/dev/null | \
            openssl x509 -noout -dates

          # Database connectivity (via SSH)
          echo "Testing database connectivity..."
          ssh production << 'ENDSSH'
            cd ${{ env.DEPLOYMENT_DIR }}
            docker exec pazpaz-db pg_isready -U pazpaz || exit 1
            echo "‚úÖ Database is accessible"
          ENDSSH

          # Redis connectivity
          echo "Testing Redis connectivity..."
          ssh production << 'ENDSSH'
            cd ${{ env.DEPLOYMENT_DIR }}
            docker exec pazpaz-redis redis-cli ping || exit 1
            echo "‚úÖ Redis is accessible"
          ENDSSH

          echo "‚úÖ All smoke tests passed"

      - name: Verify deployment metrics
        if: inputs.dry_run != true
        continue-on-error: true
        run: |
          echo "Checking deployment metrics..."

          ssh production << 'ENDSSH'
            cd ${{ env.DEPLOYMENT_DIR }}

            # Check container statuses
            echo "Container Status:"
            docker-compose -f docker-compose.prod.yml ps

            # Check resource usage
            echo ""
            echo "Resource Usage:"
            docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"

            # Check recent logs for errors
            echo ""
            echo "Recent API Logs:"
            docker-compose -f docker-compose.prod.yml logs --tail=20 api | grep -E "(ERROR|WARNING)" || echo "No errors in recent logs"
          ENDSSH

      - name: Update deployment summary
        if: always()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Deployment Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ **Deployment Successful**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Duration**: ${{ steps.deployment.outputs.deployment_duration }} seconds" >> $GITHUB_STEP_SUMMARY
            echo "- **URL**: https://${{ secrets.DOMAIN }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Health Check**: Passed ‚úÖ" >> $GITHUB_STEP_SUMMARY
            echo "- **Smoke Tests**: Passed ‚úÖ" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Deployment Failed**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check the logs above for failure details." >> $GITHUB_STEP_SUMMARY
            echo "To rollback, run: `./scripts/deploy.sh --rollback`" >> $GITHUB_STEP_SUMMARY
          fi

  # =============================================================================
  # Notifications
  # =============================================================================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [validate, deploy]
    if: always()
    timeout-minutes: 5

    steps:
      - name: Determine notification status
        id: status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=‚úÖ" >> $GITHUB_OUTPUT
            echo "color=good" >> $GITHUB_OUTPUT
          elif [ "${{ needs.deploy.result }}" == "cancelled" ]; then
            echo "status=cancelled" >> $GITHUB_OUTPUT
            echo "emoji=‚ö†Ô∏è" >> $GITHUB_OUTPUT
            echo "color=warning" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "emoji=‚ùå" >> $GITHUB_OUTPUT
            echo "color=danger" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        if: vars.ENABLE_SLACK_NOTIFICATIONS == 'true'
        continue-on-error: true
        run: |
          PAYLOAD=$(cat << EOF
          {
            "text": "${{ steps.status.outputs.emoji }} Deployment ${{ steps.status.outputs.status }}",
            "attachments": [{
              "color": "${{ steps.status.outputs.color }}",
              "fields": [
                {
                  "title": "Environment",
                  "value": "${{ needs.validate.outputs.environment }}",
                  "short": true
                },
                {
                  "title": "Version",
                  "value": "${{ needs.validate.outputs.image_tag }}",
                  "short": true
                },
                {
                  "title": "Triggered By",
                  "value": "${{ github.actor }}",
                  "short": true
                },
                {
                  "title": "Deployment ID",
                  "value": "${{ needs.validate.outputs.deployment_id }}",
                  "short": true
                }
              ],
              "footer": "GitHub Actions",
              "footer_icon": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png",
              "ts": $(date +%s),
              "actions": [{
                "type": "button",
                "text": "View Deployment",
                "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
              }]
            }]
          }
          EOF
          )

          curl -X POST -H 'Content-type: application/json' \
            --data "$PAYLOAD" \
            "${{ secrets.SLACK_WEBHOOK_URL }}"

      - name: Create Sentry release
        if: needs.deploy.result == 'success' && vars.ENABLE_SENTRY_RELEASES == 'true'
        continue-on-error: true
        run: |
          # Install Sentry CLI
          curl -sL https://sentry.io/get-cli/ | bash

          # Create release
          VERSION="${{ needs.validate.outputs.image_tag }}"
          sentry-cli releases new "$VERSION"
          sentry-cli releases set-commits "$VERSION" --auto
          sentry-cli releases deploys "$VERSION" new -e "${{ needs.validate.outputs.environment }}"
          sentry-cli releases finalize "$VERSION"
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}

      - name: Update GitHub deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const environment = '${{ needs.validate.outputs.environment }}';
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.ref,
              environment: environment,
              auto_merge: false,
              required_contexts: [],
              payload: {
                image_tag: '${{ needs.validate.outputs.image_tag }}',
                deployment_id: '${{ needs.validate.outputs.deployment_id }}'
              }
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: '${{ needs.deploy.result }}' === 'success' ? 'success' : 'failure',
              environment_url: 'https://${{ secrets.DOMAIN }}',
              description: 'Deployment ${{ needs.deploy.result }}'
            });

  # =============================================================================
  # Rollback Job (Manual Trigger)
  # =============================================================================
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && inputs.environment != ''
    timeout-minutes: 15
    environment:
      name: ${{ inputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          cat >> ~/.ssh/config <<EOF
          Host production
            HostName ${{ secrets.SSH_HOST }}
            User ${{ secrets.SSH_USER }}
            Port ${{ secrets.SSH_PORT || 22 }}
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking no
          EOF

      - name: Execute rollback
        run: |
          echo "üîÑ Initiating rollback..."

          ssh production << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOYMENT_DIR }}

            # Restore previous docker-compose.prod.yml if available
            if [ -f docker-compose.prod.yml.backup-* ]; then
              LATEST_BACKUP=$(ls -t docker-compose.prod.yml.backup-* | head -1)
              echo "Restoring configuration from: $LATEST_BACKUP"
              cp "$LATEST_BACKUP" docker-compose.prod.yml
            fi

            # Pull previous images and restart
            echo "Restarting with previous configuration..."
            docker compose --env-file .env.production -f docker-compose.prod.yml pull
            docker compose --env-file .env.production -f docker-compose.prod.yml up -d --force-recreate

            # Wait for services to become healthy
            echo "Waiting for services to stabilize..."
            sleep 30

            # Check health
            UNHEALTHY=$(docker compose --env-file .env.production -f docker-compose.prod.yml ps --format json | \
              jq -r 'select(.Service == "api" or .Service == "frontend" or .Service == "nginx") | select(.Health != "healthy") | .Service' | wc -l)

            if [ "$UNHEALTHY" -eq 0 ]; then
              echo "‚úÖ Rollback completed successfully"
            else
              echo "‚ùå Rollback failed - services are not healthy"
              docker compose --env-file .env.production -f docker-compose.prod.yml ps
              docker compose --env-file .env.production -f docker-compose.prod.yml logs --tail=50
              exit 1
            fi
          ENDSSH

      - name: Verify rollback
        run: |
          # Wait for services to stabilize
          sleep 15

          # Run smoke tests on rolled back version
          echo "Testing API health..."
          for i in {1..5}; do
            if curl -f -s "https://${{ secrets.DOMAIN }}/api/v1/health" | jq -e '.status == "healthy"' > /dev/null; then
              echo "‚úÖ API is responding after rollback"
              break
            fi
            echo "Retry $i/5..."
            sleep 10
          done

          # Verify frontend
          if curl -f -s "https://${{ secrets.DOMAIN }}" | grep -q "PazPaz"; then
            echo "‚úÖ Frontend is accessible after rollback"
          else
            echo "‚ùå Frontend check failed after rollback"
            exit 1
          fi

          echo "‚úÖ Rollback verification passed"